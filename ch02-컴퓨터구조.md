# CH02. 컴퓨터구조

## (2) 컴퓨터가 이해하는정보

- 숫자
    - 32bit
        - 부호, 지수부, 가수부
        - 1, 8, 23
    - 64bit
        - 1, 11, 52
- 문자
    - ASCII 코드로 한글표기 불가능
    - EUC-KR
        - ASCII - 제한된 글자표현의 단점 극복
        - EUC-KR(=KS X 1001 기반)**은 한글 **일부**(약 2,350개)만 포함
        - 테이블이 필요하고 테이블만큼만 필요함
    - Unicode
        - **유니코드**는 전 세계 **“문자”에 하나씩 고유한 번호**(코드포인트, U+XXXX)를 주는방식
        - 각 문자별 인코딩 테이블이 필요 없음
        - 뷁똚 이런 글자는 표현하지 못하는 EUC-KR한계 극복
        - **UTF(Unicode Transformation Format)**: 유니코드를 실제 바이트로 저장하는 인코딩 방식
    - Base64
        - Base64는 바이너리 데이터를 ASCII 텍스트로 변환하는 인코딩 방식
        - 이미지, 파일 같은 바이너리 데이터를 텍스트 형태로 전송/저장
- UTF방식
    - 주요 UTF 인코딩 방식
        - **UTF-8**: 가변 길이 (1~4바이트), ASCII 호환, 웹/데이터 파이프라인에서 가장 많이 사용
        - **UTF-16**: 가변 길이 (2 또는 4바이트), Windows/Java 내부에서 사용
        - **UTF-32**: 고정 길이 (4바이트), 메모리 효율 낮음
    - 실무에서 중요한 이유
        - Kafka 메시지, S3 파일, Redshift 테이블 모두 UTF-8 기본값
        - 한글 데이터 처리 시 인코딩 불일치하면 깨짐 발생
        - Python에서 파일 읽을 때 `encoding='utf-8'` 명시 필요
        - Spark DataFrame도 UTF-8 기본 가정
    
    **실무 팁**: 데이터 파이프라인에서는 무조건 UTF-8로 통일하는게 표준입니다.
    
- Base64
    - API 데이터 전송
        - REST API로 이미지/파일을 JSON에 담아 전송할 때
        - Kafka 메시지에 바이너리 데이터 포함 시
    - 데이터 파이프라인
        - S3에서 이미지를 읽어 Redshift에 저장 (BLOB → Base64 텍스트)
        - ML 모델 학습용 이미지 데이터를 Parquet 파일에 저장
    - 인증 토큰
        - JWT 토큰의 페이로드 부분
        - AWS Access Key/Secret Key
    
    **실무 팁**: Base64는 크기가 33% 증가하므로 대용량 데이터는 S3 URL 전달 방식이 더 효율적입니다.
    

# (5) 보조기억장치와 입출력장치

## RAID

- 여러개의 스토리지를 하나의 보조기억장치처럼 사용하는 기술

## RAID구성방법

- RAID 레벨 = 구성방법
    - RAID0, RAID1 .. RAID6 : 대표적
    - RAID10, RAID50 : 특수한 목적

## RAID0

- 데이터를 디스크에 번갈아가며 나누어 저장하는 방식
- Stripe - 분산되어 저장된 데이터
- Striping - 분산하여 저장하는 동작
- 장점
    - 빠른 입출력속도
    - 데이터를 동시에 읽고 쓸수있음
- 단점
    - 백업 안됨
    - 디스크 1개만 고장나도 전체 데이터 손실
- **실무 용도**: 임시 데이터, Spark shuffle 디스크

## RAID1

- 백업본을 남기는 방식
- 동일 데이터를 2개 디스크에 복사
- 장점
    - 백업 복구가능 → 안정성 높음
- 단점
    - 쓰기속도 2배 증가
    - 용량 50% 낭비
- **실무 용도**: DB 마스터 서버, 중요한 설정 파일

## RAID4

- 패리티정보를 저장하는 디스크를 따로 두는 구성방식
- 패리티 : 오류를 검출할 수 있는 정보
- 장점
    - 적은 디스크로 안전하게 데이터 보관
- 단점
    - 패리티를 저장하는 디스크에 병목이 발생가능
    - 백업 x

> 저럴거면 그냥 하나 백업본 만드는게 낫지않나? 왜 저런 연산과정까지해서 백업 복구작업을 더 어렵게 만드는거야 시간도 더 걸리고
> 

“용량은 아껴야겠는데 한 장 정도 고장은 버티고 싶다” → 그래서 XOR 패리티로 계산해서 한 장분만 여분으로 쓰는 RAID 5/6가 생긴 거다.

1. RAID는 가용성, 백업은 복구 시점
- RAID(특히 5/6): “디스크 하나가 지금 당장 죽어도 서비스가 바로 계속 돌아가게 하자”
    - 디스크 한 장 죽어도 I/O가 계속 된다.
    - OS/DB가 계속 그 볼륨을 쓴다.
- 백업: “과거 시점으로 돌아가기 위해 보관해둔 것”
    - 복원하는 동안은 보통 서비스를 멈추거나 느려진다.
    - 즉각성이 없다.

스트라이프 1:

- D1: A
- D2: B
- D3: C
- P: A ⊕ B ⊕ C

스트라이프 1에서 우리는 아래를 알고 있음:

- A (D1에서 읽음)
- C (D3에서 읽음)
- P1 (패리티 디스크에서 읽음) = A ⊕ B ⊕ C

우리가 모르는 건 B 하나뿐이니까 식을 B에 대해 풀면 된다.

P1 = A ⊕ B ⊕ C

⇒ B = P1 ⊕ A ⊕ C

이걸 스트라이프마다 반복하면,

- 스트라이프 1에서는 B를 복구
- 스트라이프 2에서는 E를 복구
- …
    
    이렇게 “죽은 D2가 갖고 있어야 했던 블록들”을 전부 다시 계산해서 새 디스크에 써주면 끝이다. 이게 리빌드.
    

## RAID5

- RAID4에서 패리티를 분산하여 저장하는 방식
- 데이터 + 패리티 정보를 3개 이상 디스크에 분산
- 장점
    - RAID4에서 패리티 병목 현상 해결
    - 용량 효율 좋음 (3TB 디스크 3개 = 실사용 6TB)
- **단점**
    - 쓰기 시 패리티 계산으로 성능 저하

**실무 용도**: 파일 서버, 백업 스토리지 (쓰기 적고 읽기 많은 환경)

<img width="600" height="600" alt="image" src="https://github.com/user-attachments/assets/9e57d347-0c1d-4806-9d4e-9ee217b00b11" />



## RAID 10 (1+0)

- **작동**: RAID 1 묶음을 RAID 0으로 연결 (미러링 후 스트라이핑)
- **장점**: 성능 + 안정성 둘 다 확보
- **단점**: 용량 50% 낭비
- **실무 용도**: 고성능 DB 서버 (MySQL, PostgreSQL 프로덕션)
     

<img width="600" height="300" alt="image" src="https://github.com/user-attachments/assets/86208eb8-b453-4d1c-baa3-610aec3f40da" />
