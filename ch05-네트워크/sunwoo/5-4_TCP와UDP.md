# 전송계층 - TCP와 UDP

포트를 통한 프로세스 식별

네트워크 상에서 호스트가 실행하는 프로세스는 어떻게 식별?
→ 포트번호를 통해 식별할 수 있으며, 네트워크 패킷을 주고받는 프로세스에는 포트번호가 할당

IP주소와 포트번호의 조합(IP주소:포트번호)을 통해 특정 호스트가 실행하는 특정 프로세스를 식별할 수 있다.

포트를 통한 프로세스 식별은 전송 계층(TCP, UDP)의 주된 목적이다.

16비트로 표현할 수 있는 포트 번호의 총 개수는 2^16인 65,536개 이다.

## 포트번호 종류

- 잘 알려진 포트: 0~1023
    - 가장 대중적으로 사용되는 애플리케이션을 위한 포트 번호
    - 20, 21 : FTP / 22 : SSH / 23 : TELNET / 53 : DNS
    - 67, 68 : DHCP / 80 : HTTP / 443 : HTTPS
- 등록된 포트: 1024~49151
    - 잘 알려진 포트에 비해서 덜 범용적이지만 흔하게 사용되는 애플리케이션을 위한 포트 번호
    - 1194 : OpenVPN / 1433 : Microsoft SQL Server 데이터베이스
    - 3306 : MySQL 데이터베이스 / 6379 : Redis / 8080 : HTTP 대체
- 동적 포트 : 49152~65535
    - 사설포트 또는 임시포트 라고 불리기도 함
    - 서버로서 동작하는 프로그램의 경우 잘 알려진 포트, 등록된 포트가 할당되는 경우가 많지만 클라이언트로서 동작하는 프로그램의 경우 동적 포트 번호 중에서 임의의 번호가 할당되는 경우가 많음

## 포트와 관련해서 알아야 하는 개념 : NAT

- NAT(Network Address Translation): 공인 IP 주소와 사설 IP 주소 간 변환을 위해 사용하는 기술
    - NAT는 변환하고자 하는 IP주소를 일대일로 대응하지 않고, 다수의 사설 IP주소를 그보다 적은 수의 공인 IP주소로 변환함
    - 이 때 활용하는 것이 바로 포트임
    - 포트 번호에 따라 내부 IP 주소를 구분할 수 있음
    - IP 주소 변환 과정에서 변환할 IP 주소의 쌍과 더불어 포트 번호도 함께 고려하는 포트 기반의 NAT를 NAPT(Network Address Port Translation) 라고 함

## (비)신뢰성과 (비)연결형 보장

TCP를 통해 신뢰할 수 있는 연결형 송수신이 가능하고, UDP를 통해 신뢰할 수 없는 비연결형 송수신이 가능하다.

- TCP
    - 신뢰할 수 있는 통신 - 상태관리, 흐름제어, 오류제어, 혼잡제어 제공
    - 연결형 통신 - 연결 수립, 종료 과정이 있음
    - 헤더 필드 수는 UDP보다 훨씬 많음 → UDP 헤더에 있는 모든 필드가 TCP 헤더에 포함되어 있음
        - 순서 번호 필드(sequence number): TCP 패킷의 올바른 송수신 순서를 보장하기 위해 세그먼트 첫 바이트에 매겨진 번호
        - 확인 응답 번호 필드(acknowledgement number): 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음으로 수신하길 기대하는 순서 번호
        - 제어 비트(플래그 비트): 기본적으로 8비트로 구성되며, 각 자리에 비트가 각기 다른 의미를 가짐
            - ACK : 세그먼트의 승인을 나타내기 위한 비트
            - SYN : 연결을 수립하기 위한 비트
            - FIN : 연결을 종료하기 위한 비트
- UDP
    - 신뢰할 수 없는 통신 - 상태관리, 흐름제어, 오류제어, 혼잡제어 제공 X
    - 비연결형 통신 - 연결수립, 종료과정이 없음
    - 헤더에는 포트 번호가 명시되는 필드가 있음
        - 송신지 포트(Source Port): 송신 프로세스가 할당된 포트 번호
        - 수신지 포트 (Destination Port): 수신 프로세스가 할당된 포트 번호
        - 길이 필드에는 헤더를 포함한 UDP 패킷의 바이트 크기가 명시
        - 체크섬 필드에는 송수신 과정에서의 데이터그램 훼손 여부를 알 수 있는 정보가 명시

## TCP의 연결부터 종료까지

TCP는 UDP와 달리 송수신 이전에 연결을 수립하고 송수신 이후에는 연결을 종료한다.

TCP는 세 단계로 이루어진 TCP의 연결 수립 과정인 three-way handshake를 통해 이루어진다.

- [송수신 방향 A → B] SYN 세그먼트 전송
    - 호스트 A는 SYN 비트가 1로 설정된 세그먼트를 B에게 전송함
        - SYN 비트는 연결을 수립하기 위한 비트임
    - 세그먼트의 순서 번호에는 호스트 A의 순서 번호가 포함됨
    - 처음 연결을 시작하는 이 과정을 액티브 오픈(active open) 이라고 함
        - 주로 클라이언트에 의해 수행됨
- [송수신 방향 B → A] SYN + ACK 세그먼트 전송
    - 위 전송에 대한 호스트 B의 응답을 의미
    - B는 ACK 비트와 SYN 비트가 1로 설정된 세그먼트를 A에게 전송함
    - 세그먼트의 순서 번호에는 호스트 B의 순서 번호와 위에서 보낸 세그먼트에 대한 확인 응답 번호가 포함됨
    - 연결 요청을 수신한 뒤 그에 대한 연결을 수립하는 이 과정을 패시브 오픈(passive open)이라고 함
        - 주로 서버에 의해 수행됨
- [송수신 방향 A → B] ACK 세그먼트 전송
    - 호스트 A는 ACK 비트가 1로 설정된 세그먼트를 B에게 전송함
    - 세그먼트의 순서 번호에는 호스트 A의 순서 번호와 위에서 보낸 세그먼트에 대한 확인 응답 번호가 포함됨

TCP는 송수신하는 패킷의 신뢰성을 보장하기 위해 크게 3가지 기능을 제공한다.

- 재전송을 통한 오류제어
    - 송수신 과정에서 잘못 전송된 세그먼트가 있을 경우, 재전송하여 오류를 제어함
    - 중복된 ACK 세그먼트가 도착했을 때 잘못 전송된 세그먼트가 있다는 것을 인지하는 경우
        - 송신한 세그먼트의 일부가 전송 중 유실되어 중복으로 ACK 세그먼트를 수신하게 되는 상황
    - 타임아웃이 발생했을 때 잘못 전송된 세그먼트가 있다는 것을 인지하는 경우
        - 송신하는 호스트는 모두 재전송 타이머라는 값을 유지하는데, 이 타이머의 카운트다운이 끝난 상황을 타임아웃이라고 함
- 흐름제어
    - 수신 호스트가 한 번에 받아 처리할 수 있을 만큼만 전송하는 것을 의미
    - 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 맞추는 기능임
    - 수신 호스트가 한 번에 받을 수 있는 전송량은 TCP 수신 버퍼의 크기에 의해 결정됨 - 커널에 정의되어 있음
    - TCP 헤더에 있는 윈도우(window)필드를 통해 한번에 처리할 수 있는 양을 알 수 있음
        - 윈도우 필드에는 수신 호스트가 한 번에 처리할 수 있는 수신 윈도우 크기가 명시됨
- 혼잡제어
    - 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황을 제어하기 위한 기능
    - 송신 호스트가 주체적으로 네트워크가 얼마나 혼잡한지 판단하고, 전송량을 조절할 수 있어야 함
    - 송신 호스트는 중복된 ACK 세그먼트가 도착했을 때, 타임아웃이 발생했을 때 혼잡할 수 있다고 판단함
    - 혼잡없이 전송할 수 있을 정도의 양만큼만 송신함
        - 해당 값을 혼잡 윈도우라고 함
        - 혼잡 윈도우가 크면 한번에 전송할 수 있는 세그먼트의 수가 많음을 의미
    - 혼잡 윈도우의 크기를 송신 호스트가 직접 계산해서 알아내야 되는데, 이 때 크기 연산하는 방법을 혼잡 제어 알고리즘(congestion control algorithm)이라고 함
        - 대표적으로 AIMD(Additive Increase/Multiplicative Decrease)가 있음
        - 세그먼트를 보내고, 그에 대한 응답이 오기까지 혼잡이 감지되지 않으면 혼잡 윈도우를 1씩 선형적으로 증가시키고, 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘
        - 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간을 RTT(Round Trip Time)라고 함 → RTT마다 증가하는 것임

TCP의 연결 종료는 송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고 받으며 이루어진다.

- [송수신 방향 A → B] FIN 세그먼트
    - 호스트 A는 FIN 비트가 1로 설정된 세그먼트를 호스트 B에게 전송함
    - 먼저 연결을 종료하려는 호스트에 의해 수행되는 동작을 액티브 클로즈(active close)라고 함
- [송수신 방향 B → A] ACK 세그먼트
    - 위 전송에 대한 호스트 B의 응답을 의미
    - 호스트 B는 ACK 세그먼트를 A에게 전송함
- [송수신 방향 B → A] FIN 세그먼트
    - 호스트 B는 FIN 세그먼트를 A에게 전송함
    - 연결 종료 요청을 받아들이는 호스트에 의해 수행되는 동작을 패시브 클로즈(passive close)라고 함
- [송수신 방향 A → B] ACK 세그먼트
    - 위 전송에 대한 호스트 A의 응답을 의미
    - 호스트 A는 ACK 세그먼트를 B에게 전송함

## TCP의 상태 관리

TCP는 상태를 유지하고 관리하는 프로토콜이라는 점에서 스테이트풀 프로토콜(stateful protocol)이라고 부른다.

여기에서 상태는 현재 어떤 통신 과정에 있는지를 나타내는 정보를 의미하며, 여러 상태에 대한 설명은 다음과 같다.

- 연결이 수립되지 않았을 때 주로 활용되는 상태
    - CLOSED : 아무런 연결이 없는 상태
    - LISTEN : 연결 대기 상태(쓰리 웨이 핸드셰이크의 첫 단계인 SYN 세그먼트를 대기하는 상태)
- 연결 수립 과정에서 주로 활용되는 상태
    - SYN-SENT : 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤, 응답인 SYN + ACK 세그먼트를 기다리는 상태 (연결 요청 전송)
    - SYN-RECEIVED : 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤, 응답인 ACK 세그먼트를 기다리는 상태 (연결 요청 수신)
    - ESTABLISHED : 쓰리 웨이 핸드셰이크가 끝난 뒤 데이터를 송수신할 수 있는 상태 (연결 수립)
- 연결 종료 과정에서 주로 활용되는 상태
    - FIN-WAIT-1 : 액티브 클로즈 호스트가 FIN 세그먼트로 연결 종료 요청을 보낸 상태 (연결 종료 요청 전송)
    - CLOSE-WAIT : FIN 세그먼트를 받은 패시브 클로즈 호스트가 응답으로 ACK 세그먼트를 보내고 대기하는 상태 (연결 종료 요청 승인)
    - FIN-WAIT-2 : FIN-WAIT-1 상태에서 ACK 세그먼트를 받은 상태
    - LAST-ACK : CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 대기하는 상태
    - TIME-WAIT : 액티브 클로즈 호스트가 마지막 ACK 세그먼트를 전송한 뒤 접어드는 상태
