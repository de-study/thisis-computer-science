# 해시 테이블

`해시 테이블`: 키와 값의 대응으로 이루어진 표(테이블)와 같은 자료구조

- 키: 해시 테이블에 대한 입력
- 값: 키를 얻고자 하는 데이터

<img width="1344" height="268" alt="image" src="https://github.com/user-attachments/assets/c7fbf7a2-9d1e-4ec8-ad0e-c30361e6da06" />


- 해시 테이블은 운영체제 내부에서도 자주 사용
    - 해시 테이블을 페이지 캐시, 아이노드 캐시 등을 활용하기도 함
- 다양한 프로그래밍 언어에서 해시 테이블 지원:
    
<img width="796" height="336" alt="image" src="https://github.com/user-attachments/assets/63d07ccd-c41e-4dbb-926c-f3e5990a6288" />

    

# 해시 테이블의 구조와 동작

- 키를 통해 얻고자 하는 데이터는 **버킷**에 저장
    - 버킷은 여러 개가 존재하며, 버킷들은 배열을 형성
- 해시 함수는 키를 인자로 버킷에 접근할 인덱스 반환
    - 키를 해시 함수에 통과시켜 원하는 버킷에 접근
    
    <img width="620" height="384" alt="image" src="https://github.com/user-attachments/assets/1cbb4291-52ef-4619-8736-00419d794063" />

    
- 로드팩터: 해시 테이블에 저장된 데이터 수를 버킷의 수로 나눈 값
    - 해시 테이블이 현재 얼마나 가득 차 있는지에 대한 지표
    - 로드 팩터가 클수록 해시 테이블의 성능이 떨어짐

## 해시 함수

1. 해시 함수
- 임의의 길이를 지닌 데이터를 **고정된 길이의 데이터로 변환하는 단방향 함수**
    - 단방향이기 때문에 입력 데이터를 고정된 해시 값으로 변환 가능
    - 역으로 해시값을 토대로 입력 데이터를 유추하기 어려움
1. 해시 알고리즘
- 해시 함수의 연산 방법
- 대표적인 해시 알고리즘: MD5, SHA-1, SHA-256 등
- 같은 데이터라도 적용된 해시 알고리즘에 따라 해시 값의 길이나 값이 달라짐

<img width="1190" height="552" alt="image" src="https://github.com/user-attachments/assets/12749976-9336-4d86-ae5c-805a9cb7e8bd" />


### 해시 함수 사용 예제

- 무작위 값 생성
- 단방향 암호 생성
    - 비밀번호 저장 시 사용
    - 대표적인 해시 함수 bcrypt, PBKDF2, scypt 등
- 데이터의 무결성 검증:
    1. 데이터 전송 전에 송신자가 데이터에 대한 해시 값을 먼저 계산, 이를 데이터와 함께 전송
    2. 수신자는 데이터로 해시 값을 계산, 계산된 해시 값과 전달받은 해시 값 비교
    3. 두 값이 일치하면 전송, 일치하지 않으면 데이터가 잘못 전송되었음을 파악 가능
    
    <img width="886" height="398" alt="image" src="https://github.com/user-attachments/assets/d6f2dbad-76ef-4d24-932f-a7832964ac5e" />

    

### 해시 함수 장단점

- 장점: 빠른 검색 속도
    - 일반적인 상황에서 해시 테이블을 활용한 검색, 삽입, 삭제 연산의 시간 복잡도는 O(1)
    - 입력과 무관하게 항상 일정한 속도 보장
- 단점:
    - 속도가 빠른 만큼 상대적으로 **많은 메모리 공간 소모 →** 데이터가 매우 많을 경우 공간 복잡도가 시간 복잡도만큼 우수하지 않음을 의미
    - 해시 충돌 문제:
    
    <img width="752" height="376" alt="image" src="https://github.com/user-attachments/assets/21d60179-18c8-4b12-9653-ff51f8dc1e52" />

    

## 해시 충돌

- `해시 충돌`: **서로 다른 키에 대해 같은 해시 값이 대응**되는 상황
- 데이터 무결성 검증 과정에서 해시 충돌 발생할 경우:
    - 서로 다른 두 파일을 같은 데이터라고 판단 → 보안 상의 위험 발생 가능

### 해시 충돌 해결 방법

1. `체이닝`: 충돌이 발생한 데이터를 연결 리스트로 추가
    - 하나의 테이블 인덱스에 여러 데이터가 연결 리스트의 노드로써 존재 가능
    - 서로 다른 키가 같은 위치로 해시되어도 단순히 연결 리스트 노드만 추가
    - 해시 테이블의 성능 저하 우려된다는 단점이 있음 → n개의 데이터가 전부 충돌할 때 탐색 성능은 O(n)으로 떨어짐

<img width="636" height="452" alt="image" src="https://github.com/user-attachments/assets/fc7ccf04-9364-4895-a220-4b2e35ca6042" />


1. `개방 주소법` : 충돌이 발생했을 때, **충돌이 발생한 버킷의 인덱스가 아닌 다른 인덱스에 데이터를 저장**
    
    2.1 선형 조사법
    
    - 조사(probe): 충돌이 발생했을 때 비어 있는 다른 버킷의 인덱스를 찾는 과정
    - 충돌이 발생한 인덱스의 **다음 인덱스부터 순차적**으로 가용한 인덱스 탐색
    - f(key) + 1, f(key) +2 … 순으로 가용한 인덱스 탐색
    
    <img width="1078" height="418" alt="image" src="https://github.com/user-attachments/assets/bea2dd2c-4c7c-4a92-9728-a578ca7007f3" />

    
    - 선형 조사법의 문제:
        - 데이터 군집화(clustering)
            - 해시 충돌이 발생하는 인덱스 인근에 충돌이 발생한 여러 데이터가 몰려 저장될 수 있음
            - 군집화되면 오랜 순차 탐색이 필요해서 성능 악화
            
            <img width="580" height="462" alt="image" src="https://github.com/user-attachments/assets/ff4b3acd-cdcc-4055-a9e0-689fa63cc94a" />

            
    
    2.2 이차 조사법
    
    - 선형법의 문제를 완화하는 방법
    - 충돌이 발생한 인덱스에서 **제곱수만큼 떨어진 거리**에 위치한 인덱스를 찾는 방법
    - 데이터 군집화 문제는 완화할 수 있지만, 근본적인 해결 방법이라고 보기는 어려움
2. `이중 해싱`: 2개의 해시 함수를 사용
- 충돌이 발생시 다른 해시 함수(보조 해시 함수) 해시 값만큼 떨어진 거리에 위치한 인덱스를 찾는 방법

<img width="862" height="150" alt="image" src="https://github.com/user-attachments/assets/4c959631-73a3-46e1-822c-68e97debd1a8" />


- 해시 함수를 통해 무작위로 인덱스가 생성될 수 있다면 선형 조사법의 군집화 문제를 상당 부분 피할 수 있음

---
이미지 출처: https://www.youtube.com/watch?v=dUs_hSG5YNE&list=PLVsNizTWUw7GVLg1B6w9PQSiO7yx8TOYA&index=26
