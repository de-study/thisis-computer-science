# 해시 테이블

`해시 테이블`: 키와 값의 대응으로 이루어진 표(테이블)와 같은 자료구조

- 키: 해시 테이블에 대한 입력
- 값: 키를 얻고자 하는 데이터

![image.png](attachment:17bc3eb1-3934-4f43-8d43-9db659e034c0:image.png)

- 해시 테이블은 운영체제 내부에서도 자주 사용
    - 해시 테이블을 페이지 캐시, 아이노드 캐시 등을 활용하기도 함
- 다양한 프로그래밍 언어에서 해시 테이블 지원:
    
    ![스크린샷 2025-11-22 오후 10.19.57.png](attachment:2f6600de-f6f1-46dd-9cca-e90f75ff2a3e:스크린샷_2025-11-22_오후_10.19.57.png)
    

# 해시 테이블의 구조와 동작

- 키를 통해 얻고자 하는 데이터는 **버킷**에 저장
    - 버킷은 여러 개가 존재하며, 버킷들은 배열을 형성
- 해시 함수는 키를 인자로 버킷에 접근할 인덱스 반환
    - 키를 해시 함수에 통과시켜 원하는 버킷에 접근
    
    ![image.png](attachment:52ddcb68-5428-4771-952d-b4faa8376b7d:image.png)
    
- 로드팩터: 해시 테이블에 저장된 데이터 수를 버킷의 수로 나눈 값
    - 해시 테이블이 현재 얼마나 가득 차 있는지에 대한 지표
    - 로드 팩터가 클수록 해시 테이블의 성능이 떨어짐

## 해시 함수

1. 해시 함수
- 임의의 길이를 지닌 데이터를 **고정된 길이의 데이터로 변환하는 단방향 함수**
    - 단방향이기 때문에 입력 데이터를 고정된 해시 값으로 변환 가능
    - 역으로 해시값을 토대로 입력 데이터를 유추하기 어려움
1. 해시 알고리즘
- 해시 함수의 연산 방법
- 대표적인 해시 알고리즘: MD5, SHA-1, SHA-256 등
- 같은 데이터라도 적용된 해시 알고리즘에 따라 해시 값의 길이나 값이 달라짐

![image.png](attachment:f4ef00d2-e869-44ac-809c-8eac1e074bb9:image.png)

### 해시 함수 사용 예제

- 무작위 값 생성
- 단방향 암호 생성
    - 비밀번호 저장 시 사용
    - 대표적인 해시 함수 bcrypt, PBKDF2, scypt 등
- 데이터의 무결성 검증:
    1. 데이터 전송 전에 송신자가 데이터에 대한 해시 값을 먼저 계산, 이를 데이터와 함께 전송
    2. 수신자는 데이터로 해시 값을 계산, 계산된 해시 값과 전달받은 해시 값 비교
    3. 두 값이 일치하면 전송, 일치하지 않으면 데이터가 잘못 전송되었음을 파악 가능
    
    ![image.png](attachment:c37d3374-703c-40f9-bef3-1a6fbedc1c7c:image.png)
    

### 해시 함수 장단점

- 장점: 빠른 검색 속도
    - 일반적인 상황에서 해시 테이블을 활용한 검색, 삽입, 삭제 연산의 시간 복잡도는 O(1)
    - 입력과 무관하게 항상 일정한 속도 보장
- 단점:
    - 속도가 빠른 만큼 상대적으로 **많은 메모리 공간 소모 →** 데이터가 매우 많을 경우 공간 복잡도가 시간 복잡도만큼 우수하지 않음을 의미
    - 해시 충돌 문제:
    
    ![image.png](attachment:fea8f5a2-aa9d-48c3-b9ac-96faf787debb:image.png)
    

## 해시 충돌

- `해시 충돌`: **서로 다른 키에 대해 같은 해시 값이 대응**되는 상황
- 데이터 무결성 검증 과정에서 해시 충돌 발생할 경우:
    - 서로 다른 두 파일을 같은 데이터라고 판단 → 보안 상의 위험 발생 가능

### 해시 충돌 해결 방법

1. `체이닝`: 충돌이 발생한 데이터를 연결 리스트로 추가
    - 하나의 테이블 인덱스에 여러 데이터가 연결 리스트의 노드로써 존재 가능
    - 서로 다른 키가 같은 위치로 해시되어도 단순히 연결 리스트 노드만 추가
    - 해시 테이블의 성능 저하 우려된다는 단점이 있음 → n개의 데이터가 전부 충돌할 때 탐색 성능은 O(n)으로 떨어짐

![image.png](attachment:b9ca26c1-022d-4f24-967b-550dfd8f1775:image.png)

1. `개방 주소법` : 충돌이 발생했을 때, **충돌이 발생한 버킷의 인덱스가 아닌 다른 인덱스에 데이터를 저장**
    
    2.1 선형 조사법
    
    - 조사(probe): 충돌이 발생했을 때 비어 있는 다른 버킷의 인덱스를 찾는 과정
    - 충돌이 발생한 인덱스의 **다음 인덱스부터 순차적**으로 가용한 인덱스 탐색
    - f(key) + 1, f(key) +2 … 순으로 가용한 인덱스 탐색
    
    ![image.png](attachment:97b5dbc5-25a2-4012-946f-06ccb38adb15:image.png)
    
    - 선형 조사법의 문제:
        - 데이터 군집화(clustering)
            - 해시 충돌이 발생하는 인덱스 인근에 충돌이 발생한 여러 데이터가 몰려 저장될 수 있음
            - 군집화되면 오랜 순차 탐색이 필요해서 성능 악화
            
            ![스크린샷 2025-11-22 오후 10.11.54.png](attachment:f95e7f7e-deb4-4edc-97d2-2e0afae824a4:스크린샷_2025-11-22_오후_10.11.54.png)
            
    
    2.2 이차 조사법
    
    - 선형법의 문제를 완화하는 방법
    - 충돌이 발생한 인덱스에서 **제곱수만큼 떨어진 거리**에 위치한 인덱스를 찾는 방법
    - 데이터 군집화 문제는 완화할 수 있지만, 근본적인 해결 방법이라고 보기는 어려움
2. `이중 해싱`: 2개의 해시 함수를 사용
- 충돌이 발생시 다른 해시 함수(보조 해시 함수) 해시 값만큼 떨어진 거리에 위치한 인덱스를 찾는 방법

![image.png](attachment:d07c16f2-3671-4459-adaf-8767c02d3010:image.png)

- 해시 함수를 통해 무작위로 인덱스가 생성될 수 있다면 선형 조사법의 군집화 문제를 상당 부분 피할 수 있음
