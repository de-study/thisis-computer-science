# 서브 쿼리와 조인

- `서브 쿼리`: 다른 SQL문이 포함된 SQL문을 의미
- `조인`: 2개의 테이블을 하나로 합치는 것을 의미

## 여러 테이블에 질의하기

```sql
SELECT 테이블1.필드1, 테이블1.필드2, 테이블2.필드3
	FROM 테이블1, 테이블2
	WHERE 테이블1.필드1 = 테이블2.필드2;
```

## 서브 쿼리

- 일반적 의미: 내부에 다른 SQL 문이 포함되어 있는 SQL 문
- MySQL 공식 문서 정의: 다른 SQL문 안에 있는 SELECT 문
- SELECT, INSERT, UPDATE, DELETE문 안에 포함될 수 있음

## 조인

### 조인의 종류

1. **내부 조인 (Inner Join)**
- 가장 많이 사용되는 조인 방식
- 두 테이블 모두에서 조인 조건에 일치하는 데이터가 있는 경우에만 결과로 출력
- 교집합과 유사하며, 어느 한 쪽에만 데이터가 있다면 결과에서 제외

2. **외부 조인 (Outer Join)**
- 조건에 일치하지 않는 데이터라도 특정 테이블의 데이터를 모두 보여줄 때 사용
- 일치하는 상대 데이터가 없으면 `NULL`로 채워짐
    - `Left Outer Join`: 왼쪽 테이블의 모든 행을 포함하고, 오른쪽은 조건에 맞는 것만 가져옴
    - `Right Outer Join`: 오른쪽 테이블의 모든 행을 포함하고, 왼쪽은 조건에 맞는 것만 가져옴
    - `Full Outer Join`: 양쪽 테이블의 모든 행을 포함하는 합집합 형태 - 보통 `UNION` 사용

3. **교차 조인 (Cross Join)**
- 별도의 조인 조건 없이 두 테이블의 모든 행을 서로 조합
- 왼쪽 N행과 오른쪽 M행의 곱인 N x M행이 결과로 나옴 (카테시안 곱)

4. **셀프 조인 (Self Join)**
- 별도의 테이블이 아닌 자기 자신과 조인을 수행
- 하나의 테이블 내에서 상사-부하 관계나 카테고리 계층 구조를 조회할 때 활용
    - 하나의 `Employees` 테이블 안에 사원 정보와 그 사원의 직속 상사(매니저) 정보가 함께 들어 있는 경우, **'어떤 사원의 매니저 이름이 무엇인지'를 알고 싶다면 자기 자신을 한 번 더 참조해야 함**
  <br>
    
    | **emp_id (사원번호)** | **name (이름)** | **manager_id (매니저번호)** |
    | --- | --- | --- |
    | 1 | 김철수 | NULL (대표) |
    | 2 | 이영희 | 1 |
    | 3 | 박민수 | 1 |
    | 4 | 최지우 | 2 |

<br>

# 뷰

- SELECT문의 결과로 만들어진 가상의 테이블
- 뷰 테이블은 하나의 논리적 테이블처럼 활용 가능

```sql
-- 뷰 생성
CREATE VIEW 뷰_이름 AS SELECT문;

-- 뷰 삭제
DROP VIEW
```

## 목적

- 쿼리의 단순화, 재사용성을 높이기 위해 사용
- 여러 테이블을 조인하거나 복잡한 조건식을 사용한 SQL문을 하나의 뷰로 만들어 두면, 이후 복잡한 SQL문을 반복적으로 작성하는 대신에 보다 단순하게 동일한 결과를 얻을 수 있음
- 특정 사용자에게 테이블의 특정 데이터만을 보여주고자 할 때도 사용 가능 - 특정 뷰에 대한 접근 권한 부여 등

## 주의

- VIEW에 대한 조회(SELECT)에는 제한이 없지만 삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 등이 불가능할 수 있음

<br> 

# 인덱스

- 검색 속도 향상을 목적으로 만드는 하나 이상의 테이블 필드에 대한 자료 구조
- 인덱스는 일반적으로 `B 트리`(혹은 B 트리의 변형) 형태
- 인덱스는 데이터가 충분히 많은 테이블, 조회가 빈번히 이루어지는 테이블 필드에 만들어 활용하는 것이 좋음
- 일반적으로 테이블당 3개 이하 권장

## 종류

### 1. **클러스터형 인덱스**
- 테이블당 하나씩 생성 가능 - 기본키
- 테이블 내에 기본 키로 지정된 필드는 기본적으로 클러스터형 인덱스로 간주
- 기본 키가 없다면 NOT NULL 제약 조건과 UNIQUE 제약 조건이 있는 필드(NULL값이 될 수 없는 고유한 값을 갖는 필드)를 클러스터형 인덱스로 간주

### 2. **세컨더리 인덱스**
- 클러스터형 인덱스가 아닌 인덱스 → 논클러스터형 인덱스라고도 함
- 테이블 당 여러 개 존재 가능
- 클러스터형 인덱스를 활용한 검색보다 일반적으로 느림

## 인덱스 생성의 부작용

- 인덱스는 여러 데이터를 포함하는 자료구조이므로 인덱스가 차지하는 공간이나 생성 시간이 커질 수 있음
- 조회 성능은 향상시키지만 그 외의 작업(INSERT, UPDATE, DELETE)에 대해서는 성능 향상을 가져오지 않거나 오히려 저하
    - 새로운 데이터를 삽입하거나 기존 데이터를 수정/삭제할 때 인덱스에 대한 작업도 동시에 이루어져야 하므로 인덱스를 유지하고 갱신하는 추가적인 자원과 연산이 필요하기 때문
